<div dir="rtl">

# تولید وظایف و پیاده‌سازی الگوریتم زمان‌بندی POMIP

**نویسندگان:**  
- **محمد رضایی**  
  شماره دانشجویی: ۹۹۱۰۵۴۵۳  
- **سید محمد امین احمدزاده**  
  شماره دانشجویی: ۹۹۱۰۵۲۰۴  

---

## فهرست مطالب
1. [مقدمه](#مقدمه)  
2. [مروری بر پروژه](#مروری-بر-پروژه)  
3. [روش‌شناسی](#روش‌شناسی)  
   1. [تنظیم پارامترها](#تنظیم-پارامترها)  
   2. [تولید گراف](#تولید-گراف)  
      - [ایجاد یک DAG تصادفی](#ایجاد-یک-dag-تصادفی)  
      - [محاسبه طول مسیر طولانی‌ترین](#محاسبه-طول-مسیر-طولانی‌ترین)  
      - [تولید یک وظیفه](#تولید-یک-وظیفه)  
   3. [تولید منابع](#تولید-منابع)  
   4. [محاسبه پردازنده‌ها](#محاسبه-پردازنده‌ها)  
   5. [الگوریتم زمان‌بندی POMIP](#الگوریتم-زمان‌بندی-pomip)  
      - [صف محلی و صف سراسری](#صف-محلی-و-صف-سراسری)  
      - [قانون ۱: پیش‌دستی در خوشه](#قانون-۱-پیشدستی-در-خوشه)  
      - [قانون ۲: مهاجرت به خوشه دیگر](#قانون-۲-مهاجرت-به-خوشه-دیگر)  
      - [سیاست‌های FIFO و FPC](#سیاستهای-fifo-و-fpc)  
      - [محاسبه QoS و ترسیم نمودار](#محاسبه-qos-و-ترسیم-نمودار)  
4. [نتایج](#نتایج)  
   1. [وظایف تولید‌شده](#وظایف-تولیدشده)  
   2. [منابع مشترک](#منابع-مشترک)  
   3. [نیازمندی‌های پردازنده](#نیازمندیهای-پردازنده)  
   4. [زمان‌بندی بر اساس POMIP](#زمانبندی-بر-اساس-pomip)  
5. [نتیجه‌گیری](#نتیجهگیری)  

---

## مقدمه

در سیستم‌های زمان‌بندی واقعی، تضمین اجرای وظایف پیش از موعد تعیین‌شده (Deadline) اهمیت حیاتی دارد. این پروژه با هدف تولید وظایف به‌صورت گراف‌های جهت‌دار بدون‌حلقه (DAG)، تخصیص خصوصیات زمانی به آن‌ها، تعریف منابع مشترک و در نهایت اجرای الگوریتم زمان‌بندی **POMIP** طراحی شده است. در این الگوریتم، **پیش‌دستی** (در سطح خوشه) و **مهاجرت** (در صورت بلاک‌شدن روی منبع) نقش اساسی دارند؛ همچنین سیاست‌های متفاوتی برای مرتب‌سازی صف منابع (FIFO و FPC) مقایسه می‌شوند و **کیفیت خدمت** (QoS) برای وظایف نرم نیز اندازه‌گیری می‌شود.

## مروری بر پروژه

در این پروژه، ابتدا پارامترهای زیر برای تولید وظایف و منابع مشترک مشخص می‌گردد:

1. **تعداد وظایف** (Tasks) که هر یک به شکل یک گراف DAG تولید می‌شوند.  
2. **پارامترهای زمانی** مثل WCET، نسبت مهلت (Deadline)، و نوع گره‌های سخت (Hard) یا نرم (Soft).  
3. **منابع مشترک** که وظایف در حین اجرا ممکن است نیاز به قفل‌کردن آن داشته باشند.  
4. **محاسبه تعداد پردازنده‌ها** با دو رویکرد ساده و فدراتد.  

سپس الگوریتم **POMIP** (Preemptive On-demand Migration for Parallel processing) با **قانون ۱ (پیش‌دستی در خوشه)** و **قانون ۲ (مهاجرت به خوشه دیگر)** پیاده می‌گردد. در پایان، نمودار گانت (Gantt) برای نمایش اجراهای هم‌زمان و **نمودار QoS برحسب زمان** رسم می‌شود تا تأثیر سیاست **FIFO** و **FPC** قابل مشاهده باشد.

## روش‌شناسی

### تنظیم پارامترها

پارامترهای اصلی عبارت‌اند از:
- `NUM_TASKS`: تعداد وظایف تولیدی  
- `NODES_RANGE`: بازه تعداد گره‌های میانی در هر وظیفه  
- `WCET_RANGE`: بازه زمان اجرای بدترین حالت برای هر گره  
- `P_EDGE`: احتمال ایجاد یال بین گره‌ها  
- `D_RATIO_RANGE`: تعیین نسبت طول مسیر بحرانی به مهلت  
- `RESOURCE_RANGE`: بازه تعداد منابع مشترک  
- `ACCESS_COUNT_RANGE`: تعداد کل دسترسی‌های احتمالی به هر منبع  
- `ACCESS_LEN_RANGE`: حداکثر طول دسترسی (بخش بحرانی) به منبع  

### تولید گراف

#### ایجاد یک DAG تصادفی

تابع `create_random_dag` در چند مرحله عمل می‌کند:
1. تعداد گره‌های میانی و یک گره منبع (source) و مقصد (sink) را ایجاد می‌کند.  
2. نسبت گره‌های بحرانی را بر اساس `CRITICAL_RATIOS` تعیین می‌کند.  
3. با احتمال `P_EDGE` بین گره‌ها یال ایجاد می‌شود، تا زمانی‌که گراف حلقه‌دار نشود (بررسی مرتب‌سازی توپولوژیک).  
4. منبع به حداقل یک گره میانی و حداقل یک گره میانی به مقصد متصل می‌شود.

#### محاسبه طول مسیر طولانی‌ترین

تابع `compute_longest_path_length_dag` با مرتب‌سازی توپولوژیک و برنامه‌نویسی پویا، طول مسیر بحرانی (`L_i`) در DAG را محاسبه می‌کند.

#### تولید یک وظیفه

تابع `generate_one_task` با استفاده از گراف تصادفی میانی، وظیفه را به صورت یک DAG نهایی ساخته و پارامترهای زیر را برای هر وظیفه حساب می‌کند:
- **C_i**: مجموع WCET تمام گره‌های میانی  
- **L_i**: طول مسیر بحرانی  
- **D_i** و **T_i**: تعیین‌شده بر اساس نسبت بحرانی و سراسری  
- **U_i**: نسبت بهره‌وری از `C_i / T_i`  

همچنین برای هر گره بحرانی یا نرم، **`is_on_critical_path`** با کمک تابع `compute_is_on_critical_path` مشخص می‌شود تا در سیاست **FPC** از آن استفاده گردد.

### تولید منابع

تابع `generate_resources` منابع را با مشخصات زیر تولید می‌کند:
- **حداکثر طول دسترسی** در `ACCESS_LEN_RANGE`  
- **تعداد کل دسترسی** در `ACCESS_COUNT_RANGE`  
- **توزیع دسترسی‌ها** به صورت تصادفی بین وظایف.

تابع `assign_resource_intervals_to_nodes` نیز مشخص می‌کند هر گره چه زمانی و به چه مدت به منابع نیاز دارد.

### محاسبه پردازنده‌ها

برای تعیین تعداد پردازنده‌ها، ابتدا بهره‌وری کلی تمام وظایف جمع شده و `m = ceil(UΣ)` محاسبه می‌شود. سپس با روش فدراتد:
1. برای هر وظیفه اگر `U_i > 1`، فرمول `ceil((C_i - L_i) / (D_i - L_i))` به‌کار می‌رود.  
2. در غیر این صورت، یک پردازنده اختصاصی به وظیفه داده می‌شود.

### الگوریتم زمان‌بندی POMIP

در این پروژه، برای زمان‌بندی وظایف DAG با منابع مشترک، الگوریتم **POMIP** با دو قانون اصلی و دو سیاست صف سراسری پیاده شده است:

#### صف محلی و صف سراسری

- به ازای هر منبع `l_q`، یک صف **سراسری** \(`GQ_q`\) ایجاد می‌شود. هر نود که می‌خواهد منبع را قفل کند، ابتدا وارد صف **محلی** \(`FQ_{q,i}`) مربوط به آن منبع و وظیفه i می‌شود. اگر در ابتدای صف محلی باشد، وارد صف سراسری می‌گردد و اگر در ابتدای صف سراسری باشد، منبع را قفل می‌کند.  
- پس از اتمام استفاده از منبع، نود از هر دو صف حذف و سرصف محلی بعدی وارد صف سراسری می‌شود.

#### قانون ۱: پیش‌دستی در خوشه

اگر نودی منبع را قفل کرده ولی در خوشه خود CPU آزادی موجود نباشد، می‌تواند یک نود غیر بحرانی در حال اجرای بخش عادی را از CPU خارج کند (به‌جز نودی که بخش بحرانی‌اش در حال اجراست).

#### قانون ۲: مهاجرت به خوشه دیگر

اگر پیش‌دستی ممکن نباشد، نود می‌تواند به خوشه‌ای مهاجرت کند که وظایف آن هم بر روی همان منبع بلاک هستند، و پس از اتمام بخش بحرانی به خوشه خود برگردد.

#### سیاست‌های FIFO و FPC

- **FIFO**: در صف سراسری منابع، با توجه به زمان ورود نودها به آن صف، ترتیب اجرا را تعیین می‌کند.  
- **FPC** (First-Path-Critical): نودهایی که **`is_on_critical_path=True`** دارند اولویت بالاتر داشته و در ابتدای صف می‌آیند؛ در نتیجه سریع‌تر قفل منبع را می‌گیرند.

#### محاسبه QoS و ترسیم نمودار

در انتهای اجرای الگوریتم:
- **کیفیت خدمات (QoS)** برای نودهای غیر بحرانی محاسبه می‌شود:
  - اگر قبل از Deadline تمام شوند، QoS=100%.  
  - به ازای هر واحد زمانی تأخیر پس از Deadline، ۳۰٪ از QoS آن نود کاسته می‌شود.  
- برای اندازه‌گیری **سیر رشد QoS** در طول زمان، پس از هر تیک زمان، میانگین QoS نودهای نرم تکمیل‌شده حساب و ذخیره می‌گردد. این داده‌ها در انتها به صورت نمودار رسم می‌شود.

## نتایج

### وظایف تولیدشده

هر وظیفه به صورت یک گراف DAG با گره‌های بحرانی و نرم ایجاد شده است. خصوصیات:
- **C_i**: مجموع WCET  
- **L_i**: طول مسیر بحرانی  
- **D_i, T_i**: مهلت‌ها  
- **U_i**: بهره‌وری وظیفه  

همچنین تصویری از هر وظیفه در پوشه `graphs_output` قابل مشاهده است.

### منابع مشترک

خروجی تولید منابع شامل:
- **تعداد منابع**  
- **حداکثر طول دسترسی**  
- **تعداد کل دسترسی**  
- **توزیع بین وظایف**  

### نیازمندی‌های پردازنده

1. **بر اساس بهره‌وری کلی**: 
    - `m = ceil(UΣ)`
2. **بر اساس برنامه‌ریزی فدراتد**:
    - اگر `U_i > 1`: `m_i = ceil((C_i - L_i) / (D_i - L_i))`
    - در غیر این صورت: `m_i = 1`
    
این دو روش تعداد پردازنده‌های مورد نیاز را تخمین می‌زند.

### زمان‌بندی بر اساس POMIP

- **FIFO**: نودها در صف سراسری هر منبع بر اساس **زمان ورود** مرتب می‌شوند.  
- **FPC**: اگر نودی روی مسیر بحرانی باشد، پیش از نودهای دیگر در صف سراسری قرار می‌گیرد.  

نمودارهای گانت (`fifo_schedule.png` و `fpc_schedule.png`) نشان می‌دهند که کدام نود در چه زمانی اجرا می‌شود و اگر منبعی قفل شده باشد، تحت `(R#)` نشان داده می‌شود. همچنین نمودار QoS برحسب زمان (`qos_over_time_comparison.png`) اختلاف عملکرد FIFO و FPC را در ارائه کیفیت خدمات برای وظایف Soft نمایش می‌دهد.

## نتیجه‌گیری

در این پروژه، الگوریتم POMIP پیاده‌سازی شده و رفتار آن روی مجموعه‌ای از وظایف DAG تحلیل شد. مهم‌ترین نکات عبارتند از:
1. **صف محلی و سراسری** برای هر منبع به‌خوبی مدیریت دسترسی‌های هم‌زمان را آسان می‌کند.  
2. **قانون ۱ (پیش‌دستی)** باعث می‌شود تا نودهای بحرانی بتوانند در صورت نبود CPU آزاد، نود نرم را بیرون کنند.  
3. **قانون ۲ (مهاجرت)** مکمل قانون پیش‌دستی است و در صورت عدم امکان پیش‌دستی، اجازه می‌دهد گره دارنده منبع به خوشه‌ای برود که قفل آن منبع سبب بلاک شدن گره‌های دیگر شده است.  
4. مقایسه **FIFO** و **FPC** نشان می‌دهد در شرایطی که برخورد منابع زیاد باشد و وظایف بحرانی روی مسیر بحرانی مشترک شوند، **FPC** می‌تواند بهبود QoS ایجاد کند؛ اما اگر تداخل منابع کم باشد، نتایج این دو سیاست ممکن است یکسان به نظر برسد.  
5. محاسبه **QoS** برای گره‌های نرم و رسم نمودار آن برحسب زمان، دیدی از نحوه رشد تدریجی کیفیت خدمات سیستم در طول اجرای وظایف ارائه می‌دهد.

</div>
