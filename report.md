<div dir="rtl">

# تولید وظایف و منابع برای سیستم‌های زمان‌بندی واقعی

**نویسندگان:**
- **محمد رضایی**  
  شماره دانشجویی: ۹۹۱۰۵۴۵۳
- **محمد امین احمدزاده**  
  شماره دانشجویی: ۹۹۱۰۵۲۰۴

---

## فهرست مطالب
1. [مقدمه](#مقدمه)
2. [مروری بر پروژه](#مروری-بر-پروژه)
3. [روش‌شناسی](#روش‌شناسی)
    - [تنظیم پارامترها](#تنظیم-پارامترها)
    - [تولید گراف](#تولید-گراف)
        - [ایجاد یک DAG تصادفی](#ایجاد-یک-DAG-تصادفی)
        - [محاسبه طول مسیر طولانی‌ترین](#محاسبه-طول-مسیر-طولانی‌ترین)
        - [تولید یک وظیفه](#تولید-یک-وظیفه)
    - [تولید منابع](#تولید-منابع)
    - [محاسبه پردازنده‌ها](#محاسبه-پردازنده‌ها)
4. [نتایج](#نتایج)
    - [وظایف تولید شده](#وظایف-تولید-شده)
    - [منابع مشترک](#منابع-مشترک)
    - [نیازمندی‌های پردازنده](#نیازمندی‌های-پردازنده)
5. [نتیجه‌گیری](#نتیجه‌گیری)
6. [کارهای آینده](#کارهای-آینده)

---

## مقدمه

در سیستم‌های زمان‌بندی واقعی، برنامه‌ریزی مؤثر وظایف و مدیریت منابع برای اطمینان از قابلیت اطمینان و عملکرد سیستم حیاتی است. این پروژه بر تولید گراف‌های وظیفه‌ای تصادفی (DAG)، اختصاص ویژگی‌ها به این وظایف، مدیریت منابع مشترک و محاسبه تعداد پردازنده‌های مورد نیاز با استفاده از روش‌های مختلف زمان‌بندی تمرکز دارد. هدف این است که رفتار وظایف در محیطی شبیه‌سازی شده از سیستم‌های زمان‌بندی واقعی تحلیل و بررسی شود.

## مروری بر پروژه

این پروژه شامل موارد زیر است:
- تولید تعداد مشخصی وظیفه، هر کدام به صورت یک گراف جهت‌دار بدون حلقه (DAG) نمایش داده می‌شوند.
- اختصاص ویژگی‌هایی مانند زمان اجرای بدترین حالت (WCET)، بحرانی بودن و مهلت‌ها به هر وظیفه.
- ایجاد منابع مشترک با الگوهای دسترسی تعریف‌شده میان وظایف.
- محاسبه بهره‌وری کلی پردازنده و تعیین تعداد پردازنده‌های مورد نیاز با استفاده از روش‌های برنامه‌ریزی ساده و فدراتد.
- مصورسازی گراف‌های وظیفه تولید شده برای درک و تحلیل بهتر.

## روش‌شناسی

### تنظیم پارامترها

پروژه با تعریف چندین پارامتر آغاز می‌شود که ویژگی‌های وظایف و منابع را مشخص می‌کنند:

- **تعداد وظایف (`NUM_TASKS`)**: تعداد وظایفی که تولید خواهند شد.
- **بازه تعداد گره‌ها (`NODES_RANGE`)**: بازه تعداد گره‌های میانی در هر DAG وظیفه.
- **بازه WCET (`WCET_RANGE`)**: بازه زمان اجرای بدترین حالت هر گره.
- **احتمال یال (`P_EDGE`)**: احتمال ایجاد یال بین دو گره در DAG.
- **بازه نسبت مهلت (`D_RATIO_RANGE`)**: بازه نسبت طول مسیر بحرانی به مهلت.
- **بازه منابع (`RESOURCE_RANGE`)**: بازه تعداد منابع مشترک.
- **بازه تعداد دسترسی‌ها (`ACCESS_COUNT_RANGE`)**: بازه تعداد کل دسترسی به هر منبع.
- **بازه طول دسترسی (`ACCESS_LEN_RANGE`)**: بازه حداکثر طول دسترسی (بخش بحرانی) به یک منبع.
- **احتمال تبدیل Hard به Soft (`HARD_SOFT_PROB`)**: احتمال تبدیل یک گره از نوع Hard به Soft در صورت عدم نقض محدودیت‌ها.
- **نسبت‌های بحرانی (`CRITICAL_RATIOS`)**: نسبت‌های ممکن گره‌های بحرانی به غیربحرانی در یک وظیفه.
- **دایرکتوری خروجی (`OUTPUT_DIR`)**: دایرکتوری برای ذخیره تصاویر گراف‌های تولید شده.

### تولید گراف

#### ایجاد یک DAG تصادفی

تابع `create_random_dag` یک گراف جهت‌دار بدون حلقه (DAG) تصادفی با تعداد مشخصی گره میانی تولید می‌کند. فرآیند شامل مراحل زیر است:

1. **ابتدایی‌سازی گره‌ها**: تمام گره‌های میانی به صورت پیش‌فرض نوع "Soft" دارند. گره‌های منبع و مقصد (sink) نوعی ندارند.
2. **اختصاص گره‌های بحرانی**: یک نسبت به‌صورت تصادفی از لیست `CRITICAL_RATIOS` انتخاب شده و تعداد معادل گره‌ها به عنوان "Hard" (بحرانی) تعیین می‌شوند.
3. **ایجاد یال‌ها**: برای هر جفت گره `(u, v)` که `u < v`، با احتمال `P_EDGE` یک یال جهت‌دار `(u -> v)` اضافه می‌شود، به شرطی که محدودیت‌ها نقض نشوند (مثلاً یک گره Soft نمی‌تواند فرزند Hard داشته باشد).
4. **تأیید عدم وجود حلقه**: با استفاده از مرتب‌سازی توپولوژیک، بررسی می‌شود که آیا گراف حلقه دارد یا خیر. در صورت وجود حلقه، فرآیند تکرار می‌شود تا گراف بدون حلقه تولید شود.

#### محاسبه طول مسیر طولانی‌ترین

تابع `compute_longest_path_length_dag` طول مسیر طولانی‌ترین (مسیر بحرانی) را در DAG محاسبه می‌کند. این کار با استفاده از مراحل زیر انجام می‌شود:

1. **مرتب‌سازی توپولوژیک**: گره‌ها به ترتیب توپولوژیک پردازش می‌شوند.
2. **برنامه‌نویسی پویا**: برای هر گره، طول مسیر طولانی‌ترین به آن گره بر اساس طول مسیر گره‌های پیشین و WCET آن گره به‌روز می‌شود.
3. **نتیجه**: بیشترین مقدار از طول مسیرها نشان‌دهنده طول مسیر بحرانی `L_i` است.

#### تولید یک وظیفه

تابع `generate_one_task` ایجاد یک وظیفه به‌صورت گراف DAG با مراحل زیر را انجام می‌دهد:

1. **تولید DAG میانی**: با استفاده از تابع `create_random_dag` ساختار اصلی DAG تولید می‌شود.
2. **اضافه‌کردن گره‌های منبع و مقصد**: یک گره منبع و یک گره مقصد به DAG اضافه می‌شوند.
3. **اختصاص WCET**: به هر گره میانی یک WCET تصادفی اختصاص داده می‌شود، در حالی که گره‌های منبع و مقصد WCET صفر دارند.
4. **محاسبه پارامترها**:
    - **C_i**: مجموع زمان اجرای تمام گره‌های میانی.
    - **L_i**: طول مسیر بحرانی.
    - **D_i**: مهلت، براساس نسبت تصادفی از `D_RATIO_RANGE` تعیین می‌شود.
    - **T_i**: برابر با `D_i`.
    - **U_i**: بهره‌وری، محاسبه‌شده به صورت `C_i / T_i`.
5. **مصورسازی گراف**: DAG با رنگ‌های متفاوت برای نوع گره‌ها مصورسازی شده و به عنوان یک تصویر در دایرکتوری خروجی ذخیره می‌شود.

### تولید منابع

تابع `generate_resources` منابع مشترک را با ویژگی‌های زیر ایجاد می‌کند:

- **حداکثر طول دسترسی**: به‌صورت تصادفی در بازه `ACCESS_LEN_RANGE` تعیین می‌شود.
- **تعداد کل دسترسی‌ها**: به‌صورت تصادفی در بازه `ACCESS_COUNT_RANGE` تعیین می‌شود.
- **توزیع دسترسی‌ها**: تعداد کل دسترسی‌ها به‌صورت تصادفی میان تمام وظایف توزیع می‌شود.

### محاسبه پردازنده‌ها

دو روش برای محاسبه تعداد پردازنده‌های مورد نیاز استفاده شده است:

1. **برنامه‌ریزی ساده**: بهره‌وری کلی تمامی وظایف جمع‌آوری شده و تعداد پردازنده‌ها برابر با بخش صحیح بالا از این مجموع تعیین می‌شود.
2. **برنامه‌ریزی فدراتد**: برای هر وظیفه به‌صورت جداگانه تعداد پردازنده‌های مورد نیاز محاسبه شده و سپس مجموع آن‌ها به‌عنوان تعداد کل پردازنده‌ها در نظر گرفته می‌شود.
    - اگر `U_i > 1`، تعداد پردازنده‌ها با استفاده از فرمول `ceil((C_i - L_i) / (D_i - L_i))` محاسبه می‌شود.
    - اگر `U_i <= 1`، یک پردازنده اختصاصی به وظیفه داده می‌شود.

## نتایج

### وظایف تولید شده

هر وظیفه به‌صورت یک DAG نمایش داده شده و شامل جزئیات زیر است:

- **شناسه وظیفه**: شناسه منحصر به‌فرد برای هر وظیفه.
- **تعداد گره‌ها**: تعداد کل گره‌ها شامل گره‌های منبع و مقصد.
- **نسبت گره‌های بحرانی**: نسبت گره‌های بحرانی به کل گره‌های میانی.
- **جزئیات گره‌ها**:
    - **شناسه**: شناسه گره.
    - **WCET**: زمان اجرای بدترین حالت.
    - **نوع**: "Hard" یا "Soft".
- **یال‌ها**: اتصالات جهت‌دار بین گره‌ها.
- **پارامترها**:
    - **C_i**: مجموع زمان اجرای.
    - **L_i**: طول مسیر بحرانی.
    - **D_i**: مهلت.
    - **T_i**: مهلت (برابر با `D_i`).
    - **U_i**: بهره‌وری.
- **تصویر گراف**: نمایش تصویری از DAG وظیفه در دایرکتوری `graphs_output` ذخیره شده است.

*مثال خروجی:*

--- Task tau_1 --- • تعداد کل گره‌ها (شامل source و sink): 12 • نسبت گره‌های بحرانی: 0.33 • گره‌ها (ID -> WCET, نوع): - 0: c=25, type=Soft - 1: c=17, type=Hard - ... • یال‌ها: [(0, 1), (1, 2), ...] • C1 = 200 • L1 = 150 • D1 = 600 • T1 = 600 • U1 = 0.333 -> تصویر گراف در فایل: graphs_output/dag_task_1.png


### منابع مشترک

منابع مشترک با ویژگی‌های زیر مشخص شده‌اند:

- **شناسه منبع**: شناسه منحصر به‌فرد برای هر منبع.
- **حداکثر طول دسترسی**: بیشترین مدت زمانی که یک وظیفه می‌تواند منبع را در اختیار داشته باشد.
- **تعداد کل دسترسی‌ها**: تعداد کل دفعاتی که منبع توسط وظایف استفاده می‌شود.
- **توزیع دسترسی‌ها**: تعداد دسترسی‌های اختصاص داده شده به هر وظیفه.

*مثال خروجی:*

• تعداد منابع (n_r) = 3

    منبع l_1: حداکثر طول دسترسی = 75 تعداد کل دسترسی = 10 توزیع بین وظایف: tau_1=2, tau_2=3, tau_3=1, ...


### نیازمندی‌های پردازنده

تعداد پردازنده‌های مورد نیاز با استفاده از دو روش محاسبه شده است:

1. **بر اساس بهره‌وری کلی**:
    - **فرمول**: `m = ceil(UΣ)`
    - **مثال**: اگر `UΣ = 9.75`، آنگاه `m = 10`.
    
2. **بر اساس برنامه‌ریزی فدراتد**:
    - **روش**: به‌صورت جداگانه برای هر وظیفه محاسبه شده و مجموع آن‌ها.
    - **مثال**: اگر `m_fed = 15`، آنگاه ۱۵ پردازنده مورد نیاز است.
    
*مثال خروجی:*

• بر اساس جمع بهره‌وری: m = ceil(UΣ) = 10 • بر اساس Federated Scheduling: m = 15


## نتیجه‌گیری

این پروژه با موفقیت یک شبیه‌سازی مبتنی بر پایتون برای تولید گراف‌های وظیفه‌ای تصادفی، اختصاص ویژگی‌های بحرانی، مدیریت منابع مشترک و تعیین نیازمندی‌های پردازنده برای سیستم‌های زمان‌بندی واقعی توسعه داد. با مصورسازی DAG وظایف و محاسبه نیازمندی‌های پردازنده با استفاده از روش‌های مختلف زمان‌بندی، پروژه بینش‌های ارزشمندی در زمینه برنامه‌ریزی وظایف و مدیریت منابع در سیستم‌های پیچیده ارائه می‌دهد.

## کارهای آینده

- **الگوریتم‌های برنامه‌ریزی پیشرفته‌تر**: پیاده‌سازی و مقایسه الگوریتم‌های زمان‌بندی اضافی مانند زمان‌بندی نرخ‌گذاری (RMS) و اولین مهلت اول (EDF).
- **مدل‌های رقابت منابع**: ادغام مدل‌های پیچیده‌تر برای رقابت منابع و مکانیزم‌های همگام‌سازی.
- **آزمایش‌های مقیاس‌پذیری**: آزمایش سیستم با تعداد بیشتری وظیفه و منبع برای ارزیابی مقیاس‌پذیری.
- **رابط کاربری**: توسعه یک رابط کاربری گرافیکی (GUI) برای اجازه دادن به کاربران جهت سفارشی‌سازی پارامترها و مصورسازی نتایج به‌صورت تعاملی.
- **ادغام داده‌های واقعی**: ادغام داده‌های وظیفه‌ای واقعی برای اعتبارسنجی و بهبود مدل‌های شبیه‌سازی.

---
</div>