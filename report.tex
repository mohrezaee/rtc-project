\documentclass[12pt,a4paper]{report}
\usepackage{xepersian}
\settextfont{XB Niloofar}
\setlatintextfont{Times New Roman}

\linespread{1.5}
\XePersianIndentfirstparafalse

\begin{document}
\title{گزارش پروژه: شبیه‌سازی و زمان‌بندی وظایف بی‌درنگ در یک سامانه خودران}
\author{نام پژوهشگر}
\date{\today}
\maketitle
\begin{center}
\Huge سلام
\end{center}

\tableofcontents

\chapter{مقدمه}
در یک سامانه خودران، وظایف بی‌درنگ متعددی وجود دارند؛ از جمله پردازش داده‌های حسگرها، تصمیم‌گیری برای مسیر حرکت، کنترل محرک‌ها و موارد مشابه. این وظایف در عین داشتن وابستگی‌های پیچیده، باید در زمان محدود و به‌صورت موازی اجرا شوند تا تضمین‌های بی‌درنگی (Real-Time) حفظ شود. مدل‌سازی وظایف با استفاده از گراف، روشی کارا برای نمایش این وابستگی‌ها و امکان زمان‌بندی صحیح در اختیار می‌گذارد.

در این پروژه، هدف تولید مجموعه‌هایی از وظایف (Task Sets) است که به‌صورت گراف مدل شده‌اند و سپس اعمال روش‌های زمان‌بندی و تخصیص منابع بر پایه مدل‌های \lr{federated scheduling}، \lr{POMIP} و مقایسه روش‌های صف‌بندی \lr{FIFO} و \lr{Critical Path First} می‌باشد. همچنین در حین اجرای وظایف، برای دسترسی انحصاری به منابع مشترک از مکانیزم‌های همگام‌سازی بهره گرفته شده است.

در نهایت، نتایج زمانبندپذیری (Schedulability) به ازای پارامترهای مختلفی همچون بهره‌وری نرمال شده، تعداد وظایف، تعداد منابع، طول دسترسی به منابع، نسبت گره‌های بحرانی به غیربحرانی و غیره استخراج و با استفاده از نمودارها نمایش داده شده است.

\chapter{تولید وظایف و گراف‌ها}
\section{مدل‌سازی وظیفه با گراف Erdős–Rényi}
هر وظیفه به صورت یک گراف جهت‌دار بدون دور (DAG) مدل می‌شود. تولید گراف با استفاده از مدل \lr{Erdős–Rényi} به شکل $G(|V_i|, p)$ صورت می‌گیرد که در آن $|V_i|$ تعداد گره‌ها و $p=0.1$ احتمال وجود یال بین هر دو گره است. برای هر گراف:
\begin{itemize}
\item تعداد گره‌ها به صورت تصادفی از بازه [5, 20] انتخاب می‌شود.
\item پس از تولید، یک گره مبدا (source) با زمان اجرای صفر به ابتدای گراف و یک گره مقصد (sink) با زمان اجرای صفر به انتهای گراف اضافه می‌گردد.
\end{itemize}

\section{گره‌های بحرانی و غیربحرانی}
گره‌های گراف ترکیبی از گره‌های \lr{hard real-time} (بحرانی) و \lr{soft real-time} (غیربحرانی) می‌باشند. نسبت گره‌های بحرانی به کل گره‌ها به صورت تصادفی بین [0.4, 1] انتخاب می‌شود. قاعده مهم این است که گره‌های بحرانی فرزند گره‌های غیربحرانی نباشند.

\section{زمان اجرای گره‌ها و محاسبه پارامترها}
زمان اجرای هر گره (به‌جز \lr{source} و \lr{sink}) به‌صورت تصادفی بین [20,40] انتخاب می‌شود. با داشتن زمان اجرای گره‌ها:
\begin{itemize}
\item $C_i$: مجموع زمان اجرای تمامی گره‌های وظیفه $i$
\item $L_i$: طول مسیر بحرانی، بلندترین مسیر از \lr{source} تا \lr{sink}
\item $D_i$: مهلت نسبی که با توجه به نسبت $L_i / D_i \in [0.125,0.25]$ تعیین می‌شود.
\item $T_i = D_i$: پریود وظیفه برابر با مهلت آن در نظر گرفته می‌شود.
\item $U_i = \frac{C_i}{T_i}$: بهره‌وری وظیفه محاسبه می‌گردد.
\end{itemize}

\chapter{منابع مشترک و تخصیص آن‌ها}
\section{تعداد منابع و دسترسی‌ها}
تعداد منابع مشترک در سامانه $n_r$ یک عدد تصادفی بین [1,5] انتخاب می‌شود. هر وظیفه ممکن است در اجرای خود به این منابع دسترسی انحصاری نیاز داشته باشد. تعداد کل درخواست‌ها به هر منبع به صورت تصادفی در بازه [8,64] انتخاب و بین وظایف توزیع می‌شود.

\section{طول دسترسی به منابع}
حداکثر طول دسترسی به هر منبع به صورت تصادفی بین [5,10] بوده و طول واقعی دسترسی هر وظیفه به آن منبع بین [1, max] انتخاب می‌شود. دسترسی‌ها \lr{non-nested} هستند؛ یعنی تا زمانی که وظیفه منبعی را آزاد نکرده، اجازه دسترسی به منبع دیگری ندارد.

\chapter{محاسبه تعداد پردازنده و زمان‌بندی}
\section{تعیین تعداد کل پردازنده‌ها}
تعداد کل پردازنده‌ها از رابطه زیر محاسبه می‌شود:
\[
m = \left\lceil \frac{\sum U_i}{U_{norm}} \right\rceil
\]
در این فرمول $U_{norm}$ مقدار بهره‌وری نرمال شده است که در بازه [0.1,1] در سناریوهای مختلف در نظر گرفته می‌شود.

\section{\lr{Federated Scheduling}}
این روش بین وظایفی با $U_i > 1$ و $U_i \leq 1$ تمایز قائل می‌شود:
\begin{itemize}
\item برای وظایف با $U_i > 1$: 
\[
m_i = \left\lceil \frac{C_i - L_i}{D_i - L_i} \right\rceil
\]
سپس $m_i$ پردازنده به‌صورت انحصاری به آن وظیفه تخصیص می‌یابد.
\item برای وظایف با $U_i \leq 1$: یک پردازنده به‌صورت انحصاری اختصاص می‌یابد.
\end{itemize}

اگر مجموع پردازنده‌های اختصاص‌یافته بیشتر از $m$ محاسبه‌شده شود، آن مجموعه وظیفه زمانبندپذیر نخواهد بود.

\chapter{مدیریت منابع با الگوریتم POMIP و سیاست‌های صف‌بندی}
\section{\lr{POMIP}}
برای مدیریت دسترسی انحصاری به منابع مشترک، از الگوریتم \lr{POMIP} که بر پایه مفهوم سمفور طراحی شده، استفاده می‌کنیم. در این الگوریتم، برای هر وظیفه یک صف محلی (Local Queue) و برای هر منبع یک صف سراسری (Global Queue) وجود دارد.

\section{سیاست‌های صف‌بندی}
دو سیاست برای مرتب‌سازی درخواست‌ها در صف در نظر می‌گیریم:
\begin{enumerate}
\item \lr{FIFO}: اولین درخواست وارد شده، اولین خارج می‌شود.
\item \lr{Critical Path First}: در این حالت، اولویت با گره‌هایی است که در مسیر بحرانی وظیفه قرار دارند.
\end{enumerate}

با اجرای شبیه‌سازی زمان‌بندی با هر دو سیاست فوق، میزان زمانبندپذیری را محاسبه و مقایسه می‌کنیم.

\chapter{شبیه‌سازی و تولید داده‌ها}
\section{روش شبیه‌سازی}
برای شبیه‌سازی:
\begin{itemize}
\item تعداد وظایف در یک مجموعه از [1,14] انتخاب می‌شود.
\item برای هر وظیفه گراف با روش Erdős–Rényi تولید می‌شود.
\item پارامترهای $C_i, L_i, D_i, T_i, U_i$ محاسبه می‌گردد.
\item منابع تولید و درخواست‌ها تخصیص داده می‌شود.
\item تعداد پردازنده‌ها بر اساس فرمول داده شده محاسبه و با روش \lr{federated scheduling} تخصیص می‌یابد.
\end{itemize}

این فرایند برای 100 مجموعه وظیفه تکرار و داده‌های مربوطه ذخیره می‌گردد.

\section{معیارهای ارزیابی و نمودارها}
نمودارهای زیر برای مقادیر میانگین زمانبندپذیری رسم می‌شوند:
\begin{itemize}
\item میانگین زمانبندپذیری در مقابل $U_{norm} \in [0.1, 1]$
\item میانگین زمانبندپذیری در مقابل تعداد درخواست‌های متفاوت (8 تا 64)
\item میانگین زمانبندپذیری در مقابل تعداد منابع مشترک مختلف (1 تا 5)
\item میانگین زمانبندپذیری در مقابل حداکثر زمان دسترسی (5 تا 10)
\item میانگین زمانبندپذیری در مقابل تعداد وظایف مختلف (1 تا 14)
\item میانگین زمانبندپذیری در مقابل تعداد هسته‌های متفاوت $m = [2,4,8,32]$ (با $U_{norm}=0.5$)
\item میانگین زمانبندپذیری در مقابل نسبت گره‌های بحرانی به غیربحرانی ([0.4,1])
\item میانگین کیفیت خدمات (کیفیت اجرای گره‌های غیربحرانی پس از اجرای بحرانی‌ها)
\end{itemize}

\chapter{نتایج و نتیجه‌گیری}
پس از اجرای شبیه‌سازی و تولید نمودارها، نتایج زیر به‌دست آمد:
\begin{itemize}
\item افزایش $U_{norm}$ سبب کاهش زمانبندپذیری مجموعه وظایف می‌شود.
\item افزایش تعداد درخواست‌های منابع و طول زمان دسترسی به آن‌ها باعث کاهش زمانبندپذیری است.
\item افزایش تعداد منابع و افزایش تعداد وظایف بسته به ساختار گراف‌ها و نحوه تخصیص منابع می‌تواند تاثیرات مختلفی بر زمانبندپذیری داشته باشد.
\item سیاست \lr{Critical Path First} نسبت به \lr{FIFO} در بسیاری از موارد کارایی بهتری از نظر زمانبندپذیری نشان می‌دهد، زیرا گره‌های بحرانی که تعیین‌کننده مهلت نهایی وظیفه هستند، اولویت بالاتری در دسترسی به منابع پیدا می‌کنند.
\end{itemize}

در پایان، با توجه به نتایج به‌دست آمده، \lr{federated scheduling} همراه با الگوریتم \lr{POMIP} و اعمال سیاست \lr{Critical Path First} می‌تواند زمانبندپذیری مجموعه وظایف را در سیستم‌های چندپردازنده‌ای بی‌درنگ افزایش دهد.

\end{document}
